Write Lesson 10: Process Control & Systemd Services for Chapter 10: Linux Mastery for Digital FTEs.

**Output path**: `/mnt/g/voice_learning/book_project/apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/10-process-control-systemd.md`

**CONTENT SOURCE**: REWRITE (45% preserved from v1 L06)

**Execute autonomously without confirmation. Write the file directly. Return only a brief completion report (NOT the full file content).**

## Lesson Parameters

- CEFR: B2 | Bloom: Analyze | Layer: L2 (AI Collaboration) | Duration: 60 min
- sidebar_position: 10
- chapter: 10
- lesson: 10
- Max file size: 25KB
- New concepts (count: 6, at B2 limit):
  1. systemd service file structure ([Unit], [Service], [Install])
  2. Restart policy (Restart=on-failure — correct from the start per FR-013)
  3. Start-limit protection (StartLimitBurst, StartLimitIntervalSec, RestartSec)
  4. Service lifecycle (systemctl start/stop/enable/disable/status)
  5. Service logs (journalctl -u, -f for follow, --since for time ranges)
  6. Resource limits (MemoryMax, CPUQuota in service file)

## Learning Objectives

- LO-10-1: Write a systemd .service file with correct section structure [Bloom: Apply | B2]
- LO-10-2: Configure restart policies (Restart=on-failure) with start-limit protection [Bloom: Analyze | B2]
- LO-10-3: Monitor services using systemctl status and journalctl -u [Bloom: Apply | B2]
- LO-10-4: Set resource limits (MemoryMax, CPUQuota) for agent processes [Bloom: Apply | B2]

## CRITICAL REQUIREMENTS

### 1. agent_main.py Deployment
This lesson introduces and deploys the sample agent from `/mnt/g/voice_learning/book_project/specs/001-linux-mastery-v2/assets/agent_main.py`. Read that file and incorporate it into the lesson as the agent being deployed as a systemd service. Show students how to copy it to the server and run it.

### 2. CANONICAL HEALTH CHECK SCRIPT (FR-017)
This lesson contains the ONE canonical agent health check script. All other lessons in the chapter reference it via markdown link. Include this exact script:

```bash
#!/bin/bash
# Canonical agent health check - referenced from other lessons
# Location: Taught in Lesson 10, section "Agent Health Checks"
set -euo pipefail

SERVICE_NAME="${1:?Usage: check-agent-health.sh <service-name>}"

check_service() {
    systemctl is-active --quiet "$SERVICE_NAME"
}

check_health_endpoint() {
    local port="${2:-8000}"
    curl -sf "http://localhost:${port}/health" > /dev/null 2>&1
}

check_resources() {
    local mem_usage
    mem_usage=$(systemctl show "$SERVICE_NAME" --property=MemoryCurrent --value)
    echo "Memory: ${mem_usage}"
}

main() {
    echo "=== Agent Health Check: $SERVICE_NAME ==="

    if check_service; then
        echo "[OK] Service is running"
    else
        echo "[FAIL] Service is not running"
        exit 1
    fi

    if check_health_endpoint; then
        echo "[OK] Health endpoint responding"
    else
        echo "[WARN] Health endpoint not responding"
    fi

    check_resources
    echo "=== Check complete ==="
}

main "$@"
```

### 3. FACTUAL FIX (FR-013)
Teach `Restart=on-failure` as the default from the start. Do NOT teach `Restart=always` first and then correct it. Include a brief note explaining why `Restart=always` is problematic (prevents controlled stops via `systemctl stop`), but `on-failure` is the correct production default.

## Teaching Modality

Progressive complexity — Start with minimal .service file, add features incrementally (restart policy → start-limit → resource limits → health check).

## Three Roles Invisibility Strategy (CRITICAL — NO labels like "AI as Teacher")

The Three Roles Framework MUST be active but INVISIBLE:
- **AI teaches (invisible)**: In Try With AI prompt 1, AI suggests start-limit protection and resource limits the student hasn't considered
- **Student teaches AI (invisible)**: In Try With AI prompt 2, student specifies their agent's resource requirements and AI adjusts the service file
- **AI + Student converge (invisible)**: In Try With AI prompt 3, iterative service file improvement through multiple rounds of review

## Exercises (3 required)

1. Write a minimal .service file for agent_main.py. Verify: `systemd-analyze verify /etc/systemd/system/my-agent.service`
2. Check service status and view recent logs. Verify: `systemctl status my-agent && journalctl -u my-agent --no-pager -n 5`
3. Add resource limits and verify they're applied. Verify: `systemctl show my-agent --property=MemoryMax`

## Try With AI (3 prompts required — L2 collaborative pattern)

1. "I have a FastAPI agent that crashes occasionally due to memory leaks. Design a systemd service file that handles this gracefully — automatic restarts, but with protection against restart loops. Explain each directive you include." — What you're learning: AI suggests protective mechanisms you might not know about (RestartSec, StartLimitBurst), teaching systemd features through a real problem.
2. "My agent needs exactly these constraints: max 512MB RAM, max 25% CPU, restart on crash but stop after 5 failures in 60 seconds. Generate the complete service file and explain the math behind the start-limit values." — What you're learning: Translating your specific requirements into systemd configuration is where collaboration saves time — you know what you need, AI knows the directive syntax.
3. "Review this service file I wrote for my production agent: [paste your service file]. What's missing? What would you change for production reliability? Are there any security improvements?" — What you're learning: Multiple rounds of review progressively improve the service file, catching issues you might miss alone.

## Content Structure Requirements

1. Full YAML frontmatter with skills (6 skills at B2), learning_objectives, cognitive_load, differentiation
2. Compelling narrative opening about agent persistence (crashes, reboots, your agent must survive)
3. Every bash code block MUST have an **Output:** block showing expected output
4. 3 exercises with verification commands and expected output
5. 3 "Try With AI" prompts with "**What you're learning:**" explanations
6. End with "## Try With AI" as the LAST H2 section — NO Summary, NO What's Next sections
7. Content preserved from v1: service file anatomy, systemctl commands, journalctl, service templates
8. Content removed: Restart=always as initial teaching, Three Roles labels, duplicated health checks
9. Content added: canonical health check, resource limits, start-limit protection, agent_main.py deployment

## Reference Files to Read

- Chapter README: `/mnt/g/voice_learning/book_project/apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/README.md`
- v1 Lesson 06 (source material): `/mnt/g/voice_learning/book_project/apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/06-process-control-systemd.md` (this is the OLD v1 file — read for preserved content)
- agent_main.py: `/mnt/g/voice_learning/book_project/specs/001-linux-mastery-v2/assets/agent_main.py`
- Reference quality lesson: `/mnt/g/voice_learning/book_project/apps/learn-app/docs/02-Applied-General-Agent-Workflows/10-linux-mastery/06-bash-scripting-foundations.md` (NEW v2 L06)

## Skill Dependencies

This lesson builds on:
- L06 (bash scripting — students can write scripts with set -euo pipefail)
- L08 (security — dedicated users, permissions, SSH keys)
- L09 (networking — ports, localhost, curl for health checks)

Subsequent lessons that depend on this:
- L11 (debugging — uses systemd service and health check as debugging targets)
- L12 (workflow integration — builds on service deployment patterns)
- L14 (capstone — deploys agent using everything learned)
